Loop reduction design notes

Goal: reduce the body of a br_if loop to a form that contains only the code required for determing when a loop exits

Here's an example. It's basic block #7 of function 45 in allium.wasm. The signature of function 45 is also shown, as
well as the signature of function 17 which is called by function 45.

The comments indicate the state of the stack after the commented instruction is executed (assuming an empty stack at entry)

(func (;45;) (type 0) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i64 i64 i64 i64 i64 i64)
7 ------------------------------------------------------------
0024      local.get 4               ; [ln1]
0025      local.get 8               ; [lN5 ln1]
0026      i32.wrap_i64              ; [i32(lN5) ln1]
0027      i32.const 2               ; [2 i32(lN5) ln1]               
0028      i32.shl                   ; [(shl 2 i32(lN5)) ln1]   
0029      i32.add                   ; [(shl 2 i32(lN5))+ln1] 
0030      i32.const 0               ; [0 (shl 2 i32(lN5))+ln1]
0031      local.get 3               ; [ln0 0 (shl 2 i32(lN5))+ln1]
(* (func (;17;) (type 7) (param i32 i32 i32) (local i32) *)
0032      call 17                   ; [rn0]
0033      local.get 3               ; [ln0 rn0]
0034      i32.const 768             ; [768 ln0 rn0]
0035      i32.add                   ; [768+ln0 rn0]
0036      local.set 3               ; [rn0]
0037      local.get 8               ; [lN5 rn0]
0038      i64.const 1               ; [1L lN5 rn0]
0039      i64.add                   ; [1L+lN5 rn0]                   
0040      local.tee 8               ; [1L+lN5 rn0] 
0041      i64.const 8               ; [8 1L+lN5 rn0]
0042      i64.lt_s                  ; [1L+lN5<8 rn0]
0043      br_if 0 (;@1;)

Looking at this example closely we can see that LN5 is the loop counter, it's incremented by 1 by the code
and it's compared to 8 to determine if the loop should continue or notes.

We can convert this code to an SSA form as follows:

t0 = ln1
t1 = lN5
t2 = i32(t1)
t3 = 2
t4 = t2 shl 2
t5 = t4 + t0
t6 = 0
t7 = ln0
t8 = rn0
t9 = ln0
t10 = 768
t11 = t9+t10
ln0 = t11
t12 = lN5
t13 = 1
t14 = t12 + t13
lN5 = t14
t15 = 8
brc = lN5 < 8

From this we can see that the only code required for the loop termination condition are these lines
t12 = lN5
t13 = 1
t14 = t12 + t13
lN5 = t14
t15 = 8
t16 = lN5 < t15

this can be simplified to
lN5 = lN5 + 1
brc = lN5 < 8

We use this type to store the SSA statement and we build a list of these from the expr of the bblock
type ssa = {
  result:     string;
  op1:        string;
  op2:        string;
  operation:  string;
}

There are a couple of points to make sure we handle correctly
- it's not true that every opcode produces one SSA. For example a call of a function that returns multiple
results will generate an SSA for each of those results
- we need to keep track of whether an SSA variable is live or not. An SSA variable needs to be marked not live
when an opcode consumes it

type ssa = {
  result:           string;
  op1:              string;
  op2:              string;
  operation:        string;
  mutable alive:    bool;
}

For efficiency we store the SSA list in reverse while we build it

It turns out that there are instructions that take 3 operands e.g. select so we amend our data structure to the following:
type ssa = {
  result:           string;
  op1:              string;
  op2:              string;
  op3:              string;
  operation:        string;
  mutable alive:    bool;
}

In this example (allium/78/4) we have a loop condition of ((ln4 + 1) < ln3) and the loop body reduces to this SSA:

-t0 = pn1
-t1 = 0
-t2 = pn0
-t3 = 0
-t4 = rN0
-t5 = pn1
-t6 = 8
-t7 = pn0
-t8 = 8
-t9 = rN0
-t10 = pn1
-t11 = 16
-t12 = pn0
-t13 = 16
-t14 = rN0
-t15 = pn1
-t16 = 24
-t17 = pn0
-t18 = 24
-t19 = rN0
-t20 = pn1
-t21 = 32
-t22 = pn0
-t23 = 32
-t24 = rN0
-t25 = pn1
-t26 = 40
-t27 = pn0
-t28 = 40
-t29 = rN0
-t30 = pn1
-t31 = 48
-t32 = pn0
-t33 = 48
-t34 = rN0
-t35 = pn1
-t36 = 56
-t37 = pn0
-t38 = 56
-t39 = rN0
-t40 = pn1
-t41 = -64
-t42 = t40 - t41
-t43 = 0
-t44 = pn0
-t45 = -64
-t46 = t44 - t45
-t47 = 0
-t48 = rN0
-t49 = pn1
-t50 = 72
-t51 = pn0
-t52 = 72
-t53 = rN0
-t54 = pn1
-t55 = 80
-t56 = pn0
-t57 = 80
-t58 = rN0
-t59 = pn1
-t60 = 88
-t61 = pn0
-t62 = 88
-t63 = rN0
-t64 = pn0
-t65 = pn1
-t66 = 96
-t67 = t65 + t66
-pn1 = t67
-t69 = ln4
-t70 = 1
+t71 = t69 + t70
-ln4 = t71
-t73 = ln3
-t74 = ln4 < t73

We first extract the variables of interest from the loop condition: ln4, ln3
We now want to determine the values of each of these variables when the br_if
is executed. We do this by walking backwards through the SSA updating the 
expression for the variable when the variable changes

For ln4 we get
ln4 -> ln4 = t71 -> ln4 = t69 + t70 -> ln4 = t69 + 1 -> ln4 = ln4 + 1
so we see that ln4 is incremented by 1 in the loop

For ln3 we see its not changed by the loop

The loop terminates when ln4 >= ln3-1 and so the # of loop iterations is
1+ceil(0, ln3-ln4'-1) where ln4' is the initial value of ln4 at loop entry

Another example (allium/45/7) where the loop condition is ((lN8 + 1) < 8)

-t0 = ln4
-t1 = lN8
-t2 = i32.wrap_i64(t1)
-t3 = 2
-t4 = t2 shl t3
-t5 = t0 + t4
-t6 = 0
-t7 = ln3
-t8 = ln3
-t9 = 768
-t10 = t8 + t9
-ln3 = t10
-t12 = lN8
-t13 = 1
+t14 = t12 + t13
-lN8 = t14
-t16 = 8
-t17 = lN8 < t16

lN8 -> lN8 = t14 -> lN8 = t12 + t13 -> lN8 = t12 + 1 -> lN8 = lN8 + 1


SSA reduction algorithm

Extract the variables from the loop condition. For each variable v_i in the loop condition
build a tree that starts with (=, v_i, v_i) and uses the SSA to expand the expression for the 
second v_i node. So in the example above we have (=, lN8, lN8) -> (=, lN8, t14) -> (=, lN8, t12+t13) -> (=, lN8, t12+1)
-> (=, lN8, lN8+1)