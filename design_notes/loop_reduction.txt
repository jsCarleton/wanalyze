Loop reduction design notes

Goal: reduce the body of a br_if loop to a form that contains only the code required for determing when a loop exits

Here's an example. It's basic block #7 of function 45 in allium.wasm. The signature of function 45 is also shown, as
well as the signature of function 17 which is called by function 45.

The comments indicate the state of the stack after the commented instruction is executed (assuming an empty stack at entry)

(func (;45;) (type 0) (param i32 i32 i32) (result i32)
    (local i32 i32 i32 i64 i64 i64 i64 i64 i64)
7 ------------------------------------------------------------
0024      local.get 4               ; [ln1]
0025      local.get 8               ; [lN5 ln1]
0026      i32.wrap_i64              ; [i32(lN5) ln1]
0027      i32.const 2               ; [2 i32(lN5) ln1]               
0028      i32.shl                   ; [(shl 2 i32(lN5)) ln1]   
0029      i32.add                   ; [(shl 2 i32(lN5))+ln1] 
0030      i32.const 0               ; [0 (shl 2 i32(lN5))+ln1]
0031      local.get 3               ; [ln0 0 (shl 2 i32(lN5))+ln1]
(* (func (;17;) (type 7) (param i32 i32 i32) (local i32) *)
0032      call 17                   ; [rn0]
0033      local.get 3               ; [ln0 rn0]
0034      i32.const 768             ; [768 ln0 rn0]
0035      i32.add                   ; [768+ln0 rn0]
0036      local.set 3               ; [rn0]
0037      local.get 8               ; [lN5 rn0]
0038      i64.const 1               ; [1L lN5 rn0]
0039      i64.add                   ; [1L+lN5 rn0]                   
0040      local.tee 8               ; [1L+lN5 rn0] 
0041      i64.const 8               ; [8 1L+lN5 rn0]
0042      i64.lt_s                  ; [1L+lN5<8 rn0]
0043      br_if 0 (;@1;)

Looking at this example closely we can see that LN5 is the loop counter, it's incremented by 1 by the code
and it's compared to 8 to determine if the loop should continue or notes.

We can convert this code to an SSA form as follows:

t0 = ln1
t1 = lN5
t2 = i32(t1)
t3 = 2
t4 = t2 shl 2
t5 = t4 + t0
t6 = 0
t7 = ln0
t8 = rn0
t9 = ln0
t10 = 768
t11 = t9+t10
ln0 = t11
t12 = lN5
t13 = 1
t14 = t12 + t13
lN5 = t14
t15 = 8
brc = lN5 < 8

From this we can see that the only code required for the loop termination condition are these lines
t12 = lN5
t13 = 1
t14 = t12 + t13
lN5 = t14
t15 = 8
t16 = lN5 < t15

this can be simplified to
lN5 = lN5 + 1
brc = lN5 < 8

We use this type to store the SSA statement and we build a list of these from the expr of the bblock
type ssa = {
  result:     string;
  op1:        string;
  op2:        string;
  operation:  string;
}

There are a couple of points to make sure we handle correctly
- it's not true that every opcode produces one SSA. For example a call of a function that returns multiple
results will generate an SSA for each of those results
- we need to keep track of whether an SSA variable is live or not. An SSA variable needs to be marked not live
when an opcode consumes it

type ssa = {
  result:           string;
  op1:              string;
  op2:              string;
  operation:        string;
  mutable alive:    bool;
}

For efficiency we store the SSA list in reverse while we build it

It turns out that there are instructions that take 3 operands e.g. select so we amend our data structure to the following:
type ssa = {
  result:           string;
  op1:              string;
  op2:              string;
  op3:              string;
  operation:        string;
  mutable alive:    bool;
}
