Design Notes for reducing a segment

- add a fn reduce_segment that takes a segment and an initial_state
  and produces the final_state that's created by the code of the segment
  also update succ_cond if the segment ends in a branch condition
- add a fn that traverses a segment graph and determines the updated state for each successor segment
  for now, run 2 passes through the graph: one to determine the update state for downstream segments
  and a second to do it for upstream segments;
- add the new execution record that keeps track of program states and the conditions for execution:

(* new types *)
type segment_states =
{
  pred:          int;           (* the index of the predecessor segment *)
  initial_state: program_state  (* the state after the predecessor segment was executed *)
  final_state:   program_state  (* the state after the predecessor segment was executed *)
  succ_cond:     string;        (* the expression that must be true in order for the first successor state to be entered *) 
}

type segment =
{
          index:      int;      (* the index of this segment in the list of segments, makes things easier to have this *)
          start_op:   int;      (* index into e of the first op in the expr *)
  mutable end_op:     int;      (* index+1 of the last op in the expr *)
  mutable succ:       int list; (* segment index for segments that can be directly reached from this segment *)
  mutable segtype:	  int;      (* the control opcode that created this segment *)
  mutable nesting:    int;      (* the nesting level of the last opcode in the segment *)
  mutable labels:     int list; (* the destination labels used in BR, BR_IF, BR_TABLE instructions *)
  mutable br_dest:	  int;		(* for LOOP, BLOCK and IF instructions the segment that's the target of a branch for this instruction  *)
}

type execution =
{
  index:              int;              (* the index of the segment being executed *)
  pred_index:         int;
  succ_index:         int;
  initial:            program_state;    (* the program state before the first instruction of the segment is executed *)
  mutable final:      program_state;    (* the program state after the last instruction of the segment is executed *)
  mutable succ_cond:  string;           (* the expression that must be true in order for the first successor state to be entered *) 
}
- when printing a segment print state and condition info
